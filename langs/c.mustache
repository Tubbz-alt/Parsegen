/*
 * This file is part of Parsegen and is licensed as follows:
 *
 * Copyright (c) 2012 Will Speak
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 * Note: Portions of this file may appaer in the output of the program. These
 * portions, when as part of program output, are excempt from the above terms.
 */

#include <stdlib.h>
/* Include the user-specified modules */
{{#module}}
#include <{{.}}.h>
{{/module}}

/**
 * This parser was generated automaticlally by parsegen.py. 
 */

/*****************************************************************************
 *                          Forward Declarations                             *
 ****************************************************************************/
{{^options.notypes}}
typedef struct Par_Node_ Par_Node;
{{/options.notypes}}

{{#production}}
static Par_Node* {{name}}();
{{/production}}

/*****************************************************************************
 *                            Helper Methods                                 *
 ****************************************************************************/
static Lex_Token* eatTerminal(Lex_TokenType type) {

	if (Lex_peekNextToken()->type == type)
		return Lex_getNextToken();
	else
		return NULL;
}

/*****************************************************************************
 *                             Productions                                   *
 ****************************************************************************/
{{#nonterm}}
static Par_Node* {{name}}() {
	switch (Lex_peekNextToken()->type) {
	{{#production}}
	{{#prediction}}
	case {{.}}:
	{{/prediction}}
	{{^prediction}}
		// lambda transition
	{{/prediction}}
		{{#expansion}}
		{{#term}}
		eatTerminal({{token}});
		{{/term}}
		{{^term}}
		eat non terminal {{token}}
		{{/term}}
		{{/expansion}}
		break;
	{{/production}}
	default:
	{{#nullable}}
		return NULL;
	{{/nullable}}
	{{^nullable}}
		fprintf(stderr, "Expecting {{#first}}{{.}}, {{/first}}but found \n");
	{{/nullable}}
	}
}

{{/nonterm}}

/*****************************************************************************
 *                           User Code Section                               *
 ****************************************************************************/
{{#code}}
{{.}}
{{/code}}
